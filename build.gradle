plugins {
    id 'java'
    // https://github.com/architectury/architectury-loom
    id 'dev.architectury.loom' version '1.7-SNAPSHOT' apply false
    // https://docs.papermc.io/paper/dev/userdev
    id 'io.papermc.paperweight.userdev' version '1.7.4' apply false

    // https://github.com/Fallen-Breath/yamlang
    id 'me.fallenbreath.yamlang' version '1.4.0'
}

repositories {
    maven {
        url 'https://jitpack.io'
    }
    maven {
        url 'https://www.cursemaven.com'
    }
    maven {
        url 'https://maven.neoforged.net/releases'
    }
    maven {
        name = 'papermc'
        url = 'https://repo.papermc.io/repository/maven-public/'
    }
}

def use_architectury_loom = project.platform in ['fabric', 'quilt', 'forge', 'neoforge']
def use_paperweight = project.platform in ['paper']

if (use_architectury_loom) {
    apply plugin: 'dev.architectury.loom'
}
if (use_paperweight) {
    apply plugin: 'io.papermc.paperweight.userdev'
}

Number convertVersion(String version) {
    def parts = version.split('\\.')*.toInteger()
    def major = parts[0] * 10000
    def minor = parts[1] * 100
    def patch = parts.size() > 2 ? parts[2] : 0
    return major + minor + patch
}

def mcVersion = convertVersion(project.minecraft_version);

String MOD_ICON_PATH = 'assets/unitemplate/icon.png'
String MIXIN_CONFIG_PATH = 'unitemplate.mixins.json'
String LANG_DIR = 'assets/unitemplate/lang'
JavaVersion JAVA_COMPATIBILITY
if (mcVersion >= 12005 && !(mcVersion < 12100 && project.platform == 'forge')) {
    JAVA_COMPATIBILITY = JavaVersion.VERSION_21
} else if (mcVersion >= 11800) {
    JAVA_COMPATIBILITY = JavaVersion.VERSION_17
} else if (mcVersion >= 11700) {
    JAVA_COMPATIBILITY = JavaVersion.VERSION_16
} else {
    JAVA_COMPATIBILITY = JavaVersion.VERSION_1_8
}
JavaVersion MIXIN_COMPATIBILITY_LEVEL = JAVA_COMPATIBILITY


stonecutter.const('FABRIC', project.platform == 'fabric')
stonecutter.const('QUILT', project.platform == 'quilt')
stonecutter.const('FORGE', project.platform == 'forge')
stonecutter.const('NEOFORGE', project.platform == 'neoforge')


if (use_architectury_loom) {
    configurations {
        modRuntimeOnly.exclude group: 'net.fabricmc', module: 'fabric-loader'
    }
}

dependencies {
    // loom
    if (use_architectury_loom) {
        minecraft "com.mojang:minecraft:${project.minecraft_version}"
        mappings loom.layered {
            mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"

            // https://github.com/architectury/architectury-loom/issues/214
            if (project.platform == 'neoforge' && project.hasProperty('yarn_mappings_patch')) {
                it.mappings("dev.architectury:yarn-mappings-patch-neoforge:${project.yarn_mappings_patch}")
            }
        }
    }
    if (use_paperweight) {
        paperweight.paperDevBundle("${project.minecraft_version}-R0.1-SNAPSHOT")
    }

    if (project.platform == 'fabric') {
        modImplementation "net.fabricmc:fabric-loader:${project.fabric_loader_version}"
    }
    if (project.platform == 'forge') {
        forge "net.minecraftforge:forge:${project.minecraft_version}-${project.forge_version}"
    }
    if (project.platform == 'neoforge') {
        neoForge "net.neoforged:neoforge:${project.neoforge_version}"
    }
    if (project.platform == 'paper') {
//        compileOnly "io.papermc.paper:paper-api:${project.minecraft_version}-R0.1-SNAPSHOT"
    }
}

if (use_architectury_loom) {
    loom {
        def commonVmArgs = ['-Dmixin.debug.export=true', '-Dmixin.debug.countInjections=true']
        runConfigs.configureEach {
            // to make sure it generates all "Minecraft Client (:subproject_name)" applications
            ideConfigGenerated = true
            runDir '../../run'
            vmArgs commonVmArgs
        }

        if (project.platform == 'forge') {
            forge {
                mixinConfigs = [MIXIN_CONFIG_PATH]
            }
        }
    }
    remapJar {
        remapperIsolation = true
    }
}

String modVersionSuffix = ''
String artifactVersion = project.mod_version
String artifactVersionSuffix = ''
// detect github action environment variables
// https://docs.github.com/en/actions/learn-github-actions/environment-variables#default-environment-variables
if (System.getenv("BUILD_RELEASE") != "true") {
    String buildNumber = System.getenv("BUILD_ID")
    modVersionSuffix += buildNumber != null ? ('+build.' + buildNumber) : '-SNAPSHOT'
    artifactVersionSuffix = '-SNAPSHOT'  // A non-release artifact is always a SNAPSHOT artifact
}
String fullModVersion = project.mod_version + modVersionSuffix
String fullProjectVersion, fullArtifactVersion
// Example version values:
//   project.mod_version     1.0.3                             (the base mod version)
//   modVersionSuffix        +build.88                         (use github action build number if possible)
//   artifactVersionSuffix   -SNAPSHOT
//   fullModVersion          1.0.3+build.88                    (the actual mod version to use in the mod)
//   fullProjectVersion      v1.0.3-mc1.15.2-fabric+build.88   (in build output jar name)
//   fullArtifactVersion     1.0.3-mc1.15.2-fabric-SNAPSHOT    (maven artifact version)

processResources {
    inputs.property "id", project.mod_id
    inputs.property "name", project.mod_name
    inputs.property "version", fullModVersion
    inputs.property "minecraft_dependency", project.minecraft_dependency

    def good_files = [] as Set
    def all_files = [] as Set
    [
            'fabric':   [MIXIN_CONFIG_PATH, 'fabric.mod.json'],
            'forge':    [MIXIN_CONFIG_PATH, 'META-INF', 'META-INF/mods.toml', 'pack.mcmeta'],
            'neoforge': [MIXIN_CONFIG_PATH, 'META-INF', 'META-INF/neoforge.mods.toml', 'pack.mcmeta'],
            'paper':    ['plugin.yml'],
    ].forEach { brand, paths ->
        all_files.addAll(paths)
        if (brand == project.platform) {
            good_files.addAll(paths)
        }
    }
    all_files.forEach { it2 ->
        def path = it2 as String
        if (good_files.contains(path)) {
            filesMatching(path) {
                def valueMap = [
                        "id": project.mod_id,
                        "name": project.mod_name,
                        "version": fullModVersion,
                        "minecraft_dependency": project.minecraft_dependency,

                        "description": project.mod_description,
                        "authors": project.mod_authors,
                        "homepage": project.mod_homepage,
                        "sources": project.mod_sources,
                        "issue": project.mod_issue,
                        "java_compatibility_level": "JAVA_${MIXIN_COMPATIBILITY_LEVEL.ordinal() + 1}",
                ]
                expand valueMap
            }
        } else {
            exclude path
        }
    }

    if (project.platform in ['forge', 'neoforge']) {
        // forge requires the mod icon file to be at the resource root
        filesMatching(MOD_ICON_PATH) { f -> f.path = new File(f.path).getName() }
    }
}

// https://github.com/Fallen-Breath/yamlang
yamlang {
    targetSourceSets = [sourceSets.main]
    inputDir = LANG_DIR
}

if (use_paperweight) {
    tasks.assemble {
        dependsOn(tasks.reobfJar)
    }
    tasks.jar {
        manifest {
            attributes["paperweight-mappings-namespace"] = "mojang"
        }
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = "UTF-8"
    options.compilerArgs << "-Xlint:deprecation" << "-Xlint:unchecked"
    if (JAVA_COMPATIBILITY <= JavaVersion.VERSION_1_8) {
        // suppressed "source/target value 8 is obsolete and will be removed in a future release"
        options.compilerArgs << '-Xlint:-options'
    }
}

java {
    sourceCompatibility = JAVA_COMPATIBILITY
    targetCompatibility = JAVA_COMPATIBILITY

    // Loom will automatically attach sourcesJar to a RemapSourcesJar task and to the "build" task
    // if it is present.
    // If you remove this line, sources will not be generated.
    withSourcesJar()
}

jar {
    from(rootProject.file('LICENSE')) {
        rename { "${it}_${project.archives_base_name}" }
    }
}

tasks.register('buildAndGather') {
    subprojects {
        dependsOn project.tasks.named('build').get()
    }
    doFirst {
        println 'Gathering builds'
        def buildLibs = {
            p -> p.buildDir.toPath().resolve('libs')
        }
        delete fileTree(buildLibs(rootProject)) {
            include '*'
        }
        subprojects {
            copy {
                from(buildLibs(project)) {
                    include '*.jar'
                    exclude '*-dev.jar', '*-sources.jar'
                }
                into buildLibs(rootProject)
                duplicatesStrategy DuplicatesStrategy.INCLUDE
            }
        }
    }
}